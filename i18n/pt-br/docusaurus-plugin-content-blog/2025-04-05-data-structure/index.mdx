---
slug: data-structure
title: Estrutura de dados
tags: [estrutura de dados, fundamentos de programa√ß√£o]
description: Relembrando estrutura de dados
keywords: ["estrutura de dados", "fundamentos de programa√ß√£o"]
---

import BlogImage from '@site/src/components/blog/BlogImage';

## O que s√£o dados?

Os dados (e seus diversos tipos) s√£o os blocos b√°sicos da programa√ß√£o.
<!-- truncate -->
Eles representam uma unidade ou um elemento de informa√ß√£o que pode ser acessado atrav√©s de um identificador - por exemplo, uma vari√°vel.

<BlogImage src="/img/blog/datastructures.webp" alt="Data Structures" />


A maior parte das linguagens de programa√ß√£o trabalha com varia√ß√µes baseadas nos quatro tipos primitivos abaixo:

---

- **INT** ou n√∫mero inteiro: valores num√©ricos inteiros (positivos ou negativos);
- **FLOAT** ou o chamado "ponto flutuante": valores num√©ricos com casas ap√≥s a v√≠rgula (positivos ou negativos);
- **BOOLEAN** ou booleanos: representado apenas por dois valores, "verdadeiro" e "falso". Tamb√©m chamados de operadores l√≥gicos;
- **TEXT** ou cadeias de caracteres: sequ√™ncias ou cadeias de caracteres, utilizados para manipular textos e/ou outros tipos de dados n√£o num√©ricos ou booleanos, como hashes de criptografia.

O JavaScript, por exemplo, tem como tipos primitivos embutidos na estrutura b√°sica da linguagem: number, string, boolean e symbol (de "nome simb√≥lico", usado entre outras coisas para criar propriedades √∫nicas em objetos). J√° o C# (C-Sharp) trabalha com uma quantidade maior de tipos primitivos, de acordo com o espa√ßo de mem√≥ria que ser√° ocupado pela vari√°vel: Boolean, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, IntPtr, UIntPtr, Char, Double e Single. O C, por sua vez, n√£o tem um tipo pr√≥prio de dado booleano; false √© representado pelo n√∫mero 0 e qualquer outro algarismo representa true. Outras linguagens podem trabalhar com outras varia√ß√µes.

## Caracter√≠sticas

Cada estrutura de dados tem um conjunto de m√©todos pr√≥prios para realizar opera√ß√µes como:

- ‚¨ÜÔ∏è Inserir ou excluir elementos;
- üîé Buscar e localizar elementos;
- üîÑ Ordenar (classificar) elementos de acordo com alguma ordem especificada.

## Tipos:

- üì¶ Array
- üì¶ Linked List
- üì¶ Stack
- üì¶ Queue
- üì¶ Tree
- üì¶ Graph
- üì¶ Hash Table
- üì¶ Heap
- üì¶ Trie

### Array

O array √© uma estrutura de dados linear que armazena uma cole√ß√£o de elementos em uma √∫nica vari√°vel. Os elementos s√£o armazenados sequencialmente, um ao lado do outro, e podem ser acessados atrav√©s de um √≠ndice. Eles n√£o mudam de posi√ß√£o, mas podem ser removidos ou adicionados. S√£o do mesmo tipo de dado.

```javascript
const array = [1, 2, 3, 4, 5];

array[0]; // 1
array[1]; // 2
array[2]; // 3

array.push(6); // [1, 2, 3, 4, 5, 6]
array.pop(); // [1, 2, 3, 4, 5]
array.shift(); // [2, 3, 4, 5]
array.unshift(1); // [1, 2, 3, 4, 5]
```

### Linked List

A linked list √© uma estrutura de dados linear que armazena uma cole√ß√£o de elementos em uma √∫nica vari√°vel.

```javascript
const linkedList = [1, 2, 3, 4, 5];

linkedList[0]; // 1
linkedList[1]; // 2
linkedList[2]; // 3

linkedList.push(6); // [1, 2, 3, 4, 5, 6]
linkedList.pop(); // [1, 2, 3, 4, 5]
linkedList.shift(); // [2, 3, 4, 5]
linkedList.unshift(1); // [1, 2, 3, 4, 5]
```

### Stack

A stack √© uma estrutura de dados linear que armazena uma cole√ß√£o de elementos em uma √∫nica vari√°vel.

```javascript
const stack = [1, 2, 3, 4, 5];

stack[0]; // 1
stack[1]; // 2
stack[2]; // 3

stack.push(6); // [1, 2, 3, 4, 5, 6]
stack.pop(); // [1, 2, 3, 4, 5]
stack.shift(); // [2, 3, 4, 5]
stack.unshift(1); // [1, 2, 3, 4, 5]
```

### Queue

A queue √© uma estrutura de dados linear que armazena uma cole√ß√£o de elementos em uma √∫nica vari√°vel.

```javascript
const queue = [1, 2, 3, 4, 5];

queue[0]; // 1
queue[1]; // 2
queue[2]; // 3

queue.push(6); // [1, 2, 3, 4, 5, 6]
queue.pop(); // [1, 2, 3, 4, 5]
queue.shift(); // [2, 3, 4, 5]
queue.unshift(1); // [1, 2, 3, 4, 5]
```

### √Årvore (Tree)

Uma √°rvore √© uma estrutura de dados hier√°rquica n√£o-linear que consiste em n√≥s conectados por arestas. Cada √°rvore tem:

- Um n√≥ raiz (root)
- N√≥s pais e filhos
- N√≥s folha que n√£o tem filhos

![tree](\img\blog\tree.png)

```python
class TreeNode:
    def __init__(self, valor):
        self.valor = valor
        self.filhos = []
        
    def adicionar_filho(self, filho):
        self.filhos.append(filho)

# Exemplo de uso
raiz = TreeNode("A")
filho1 = TreeNode("B")
filho2 = TreeNode("C")
raiz.adicionar_filho(filho1)
raiz.adicionar_filho(filho2)
filho1.adicionar_filho(TreeNode("D"))
filho1.adicionar_filho(TreeNode("E"))
```

#### Casos de uso

- Representa√ß√£o de hierarquias (sistema de arquivos)
- √Årvores de decis√£o em IA
- √Årvores de express√£o em compiladores
- Organiza√ß√£o de dados (√°rvores bin√°rias de busca)

#### Complexidade

Acesso: O(log n) para √°rvores balanceadas, O(n) no pior caso
Inser√ß√£o: O(log n) para √°rvores balanceadas, O(n) no pior caso
Busca: O(log n) para √°rvores balanceadas, O(n) no pior caso
Dele√ß√£o: O(log n) para √°rvores balanceadas, O(n) no pior caso

### Graph (Grafo)

Um grafo √© uma estrutura de dados n√£o-linear que consiste em um conjunto de v√©rtices (n√≥s) conectados por arestas. Os grafos podem ser direcionados (arestas com dire√ß√£o) ou n√£o direcionados.

```python
class Graph:
    def __init__(self):
        self.graph = {}
    
    def adicionar_vertice(self, vertice):
        if vertice not in self.graph:
            self.graph[vertice] = []
    
    def adicionar_aresta(self, origem, destino):
        if origem in self.graph:
            self.graph[origem].append(destino)
        else:
            self.graph[origem] = [destino]

# Exemplo de uso
g = Graph()
g.adicionar_vertice("A")
g.adicionar_vertice("B")
g.adicionar_aresta("A", "B")
```

#### Casos de uso
- Redes sociais
- Sistemas de navega√ß√£o
- Redes de computadores
- Mapas e rotas

#### Complexidade
- Acesso: O(V + E), onde V √© o n√∫mero de v√©rtices e E √© o n√∫mero de arestas
- Inser√ß√£o: O(1)
- Busca: O(V + E)
- Dele√ß√£o: O(V + E)

### Hash Table (Tabela Hash)

Uma tabela hash √© uma estrutura de dados que implementa um array associativo, mapeando chaves para valores. Utiliza uma fun√ß√£o hash para calcular um √≠ndice onde o valor ser√° armazenado.

```javascript
const hashTable = new Map();

// Inserindo valores
hashTable.set("chave1", "valor1");
hashTable.set("chave2", "valor2");

// Acessando valores
console.log(hashTable.get("chave1")); // "valor1"

// Removendo valores
hashTable.delete("chave1");
```

#### Casos de uso
- Caches
- Bancos de dados
- Dicion√°rios
- Tabelas de s√≠mbolos em compiladores

#### Complexidade
- Acesso: O(1) em m√©dia, O(n) no pior caso
- Inser√ß√£o: O(1) em m√©dia, O(n) no pior caso
- Busca: O(1) em m√©dia, O(n) no pior caso
- Dele√ß√£o: O(1) em m√©dia, O(n) no pior caso

### Heap (Mont√≠culo)

Um heap √© uma estrutura de dados baseada em √°rvore que satisfaz a propriedade do heap. Em um heap m√°ximo, cada n√≥ pai √© maior ou igual aos seus filhos; em um heap m√≠nimo, cada n√≥ pai √© menor ou igual aos seus filhos.

```python
import heapq

# Criando um heap m√≠nimo
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappush(heap, 8)

# Removendo o menor elemento
menor = heapq.heappop(heap)  # 2
```

#### Casos de uso
- Filas de prioridade
- Algoritmos de ordena√ß√£o (Heapsort)
- Algoritmos de caminho mais curto
- Gerenciamento de mem√≥ria

#### Complexidade
- Acesso ao m√°ximo/m√≠nimo: O(1)
- Inser√ß√£o: O(log n)
- Dele√ß√£o: O(log n)
- Constru√ß√£o: O(n)

### Trie (√Årvore de Prefixos)

Uma trie √© uma estrutura de dados em √°rvore usada para armazenar strings. Cada n√≥ representa um caractere, e os caminhos da raiz at√© os n√≥s folha formam strings.

```python
class TrieNode:
    def __init__(self):
        self.filhos = {}
        self.fim_da_palavra = False

class Trie:
    def __init__(self):
        self.raiz = TrieNode()
    
    def inserir(self, palavra):
        no = self.raiz
        for char in palavra:
            if char not in no.filhos:
                no.filhos[char] = TrieNode()
            no = no.filhos[char]
        no.fim_da_palavra = True
```

#### Casos de uso
- Autocompletar
- Verifica√ß√£o ortogr√°fica
- Dicion√°rios
- Roteamento IP

#### Complexidade
- Inser√ß√£o: O(m), onde m √© o comprimento da string
- Busca: O(m)
- Dele√ß√£o: O(m)

## Conclus√£o

As estruturas de dados e Algoritmos s√£o o cerne do desenvolvimento de software e √© justamente por onde voc√™ deve come√ßar se quer aprender a programar. Cada estrutura de dado possui um caso onde √© melhor utilizada. A escolha da estrutura de dados correta pode impactar significativamente o desempenho e a manutenibilidade de uma aplica√ß√£o.

√â importante entender as complexidades de tempo e espa√ßo de cada estrutura, bem como seus casos de uso ideais. Ao dominar estas estruturas, voc√™ estar√° melhor equipado para resolver problemas complexos e otimizar suas solu√ß√µes.

Lembre-se que a pr√°tica √© essencial para internalizar estes conceitos. Experimente implementar estas estruturas na sua linguagem de programa√ß√£o e resolva problemas pr√°ticos utilizando-as, recomendo fazer um pouco de [Leetcode](https://leetcode.com/). Com o tempo, voc√™ desenvolver√° uma intui√ß√£o natural para escolher a estrutura de dados mais apropriada para cada situa√ß√£o.
